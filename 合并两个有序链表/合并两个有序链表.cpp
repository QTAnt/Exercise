[21合并两个有序链表]
(%3Ca href="https://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/"%3Ehttps://leetcode-cn.com/problems/merge-two-sorted-lists/submissions/%3C/a%3E)

将两个有序链表合并为一个新的有序链表并返回。
新链表是通过拼接给定的两个链表的所有节点组成的。

示例：

输入：1->2->4, 1->3->4

输出：1->1->2->3->4->4
【一】
：

1、先叛空，如果其中一个为空的话，则直接返回另一个链表即可

2、引入一新链表L，并定义一个tail，tail用来链接已知两个链表里较小的结点

3、两个链表从头开始依次进行比较，将相较小的结点链在新链表L后，直至其中一个链表结束

class?Solution?{
public:

????ListNode*?mergeTwoLists(ListNode*?l1,?ListNode*?l2)?{

????????//1、其中一个链表为空

????????if(l1?==?NULL){

????????????return?l2;

????????}
????????
		if(l2?==?NULL){
?
???????????return?l1;

????????}
????????
		//2、两个链表均不为空，也没结束时，过程中的链接

????????ListNode*?L?=?NULL;

????????if(l1->val?<?l2->val){

????????????L?=?l1;

????????????l1?=?l1->next;

????????}

????????else{


			L?=?l2;

????????????l2?=?l2->next;

????????}

????????//3、其中一个链表走到最后了

????????ListNode*?tail?=?L;

????????while(l1?!=?NULL?&&?l2?!=?NULL){

????????????if(l1->val?<?l2->val){

????????????????//取插入l1

????????????????tail->next?=?l1;

????????????????tail?=?l1;

????????????????l1?=?l1->next;

????????????}else{

????????????????tail->next?=?l2;

????????????????tail?=?l2;

????????????????l2?=?l2->next;

????????????}

????????}

????????if(l1?!=?NULL)

????????????tail->next?=?l1;
?
????????else

????????????tail->next?=?l2;

????????return?L;

????}

};
【二】创建一个结点，判断大小之后直接链
class?Solution?{
public:

????ListNode*?mergeTwoLists(ListNode*?l1,?ListNode*?l2)?{

????????//1、其中一个链表为空

????????if(l1?==?NULL){

????????????return?l2;

????????}

????????if(l2?==?NULL){

????????????return?l1;

????????}

???????
?ListNode*?head;//head,tail哨兵位，存储有效的数据

????????ListNode*?tail;

????????head?=?tail?=?(ListNode*)malloc(sizeof(ListNode));

????????while(l1?!=?NULL?&&?l2?!=?NULL){

????????????if(l1->val?<?l2->val){

????????????????//取插入l1

????????????????tail->next?=?l1;

????????????????tail?=?l1;

????????????????l1?=?l1->next;

????????????}else{

????????????????tail->next?=?l2;

????????????????tail?=?l2;

????????????????l2?=?l2->next;

????????????}

????????}

????????if(l1?!=?NULL)

????????????tail->next?=?l1;
?
????????else

????????????tail->next?=?l2;

            
        //?return?head->next;
??
        //可以直接返回该行，这样消耗的时间比较短，但是最好像下面那样，释放一下头节点，防止出现野指针的问题（消耗的时间相对久一点儿）

????????ListNode*?list?=?head->next

????????free(head);

????????return?list;

????}

};?????????L?=?l2;
????????????l2?=?l2->next;
????????}
????????//3、其中一个链表走到最后了
????????ListNode*?tail?=?L;
????????while(l1?!=?NULL?&&?l2?!=?NULL){
????????????if(l1->val?<?l2->val){
????????????????//取插入l1
????????????????tail->next?=?l1;
????????????????tail?=?l1;
????????????????l1?=?l1->next;
????????????}else{
????????????????tail->next?=?l2;
????????????????tail?=?l2;
????????????????l2?=?l2->next;
????????????}
????????}
????????if(l1?!=?NULL)
????????????tail->next?=?l1;?
????????else
????????????tail->next?=?l2;
????????return?L;
????}
};