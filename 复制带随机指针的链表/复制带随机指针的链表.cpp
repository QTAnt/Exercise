给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。
要求返回这个链表的**深拷贝**
**
示例：
输入：
{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}

**解释：**
节点 1 的值是 1，它的下一个指针和随机指针都指向节点
 2 。
节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。

**提示：** 你必须返回给定头的拷贝作为对克隆列表的引用。

/*

//?Definition?for?a?Node.
class?Node?{
public:

????int?val;

????Node*?next;

????Node*?random;

????Node()?{}

????Node(int?_val,?Node*?_next,?Node*?_random)?{

????????val?=?_val;

????????next?=?_next;

????????random?=?_random;??//可以指向任意结点
????}
};

*/

**解题步骤：**

1、拷贝插入：遍历链表

2、置random

3、拆解-链接



Node*?BuyNode(int?val){

????Node*?node?=?(Node*)malloc(sizeof(Node));

????node->val?=?val;

????node->next?=?NULL;

????node->random?=?NULL;

????return?node;

}

class?Solution?{

public:

????Node*?copyRandomList(Node*?head)?{

????????Node*?cur?=?head;

????????//1、拷贝插入节点

????????while(cur){

????????????Node*?next?=?cur->next;

????????????Node*?cpnode?=?BuyNode(cur->val);

????????????cur->next?=?cpnode;

????????????cpnode->next?=?next;

????????????//迭代

????????????cur?=?next;

????????}

????????//2、置random

????????cur?=?head;

????????while(cur){

????????????Node*?cpnode?=?cur->next;

????????????//置random

????????????if(cur->random)

????????????????cpnode->random?=?cur->random->next;

????????????//迭代

????????????cur?=?cur->next->next;

????????}

????????//3、拆解-链接

????????Node*?cphead?=?BuyNode(0);

????????Node*?cptail?=?cphead;

????????cur?=?head;

????????while(cur){

????????????Node*?cpnode?=?cur->next;

????????????Node*?next?=?cur->next->next;

????????????//拆解

????????????cur->next?=?next;

????????????//链接

????????????cptail->next?=?cpnode;

????????????cptail?=?cpnode;

????????????//迭代

????????????cur?=?next;

????????}

????????Node*?cplist?=?cphead->next;

????????free(cphead);

????????return?cplist;

????}

};

