//*****京东笔试（测开）******************************************************************************
//双色塔    //
//时间限制：C / C++语言 1000MS；其他语言 3000MS
//内存限制：C / C++语言 65536KB；其他语言 589824KB
//题目描述：
//现在有红，绿两种颜色的石头，现在我们需要用这两种石头搭建一个塔，塔需要满足如下三个条件：
//1． 第1层应该包含1块石头，第2层应该包含两块，第 i 层需要包含 i 块石头。
//2． 同一层的石头应该是同一个颜色（红或绿）。
//3． 塔的层数尽可能多。
//问在满足上面三个条件的前提下，有多少种不同的建造塔的方案，当塔中任意一个对应位置的石头颜色不同，我们就认为这两个方案不相同。石头可以不用完。
//输入
//输入仅包含两个正整数，分别表示红和绿砖块的数量a，b（0 <= a, b <= 2 * 10 ^ 5, a + b >= 1）。
//输出
//输出和仅包含一个正整数，表示不同的方案数对1000000007取模的结果。
//样例输入
//4 6
//样例输出
//2
//规则
//请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果
//点击“调试”亦可保存代码
//编程题可以使用本地编译器，此页面不记录跳出次数
//#include <iostream>
//#include <algorithm>
//#include <math.h>
//using namespace std;

//int main()
//{
//	int a;
//	int b;
//	while (cin >> a >> b)
//	{
//		if ((a == 0 && b == 1) || (b == 0 && a == 1))
//			cout << 1 << endl;
//
//	}
//
//	return 0;
//}
//最长区间
//时间限制：C / C++语言 1000MS；其他语言 3000MS
//内存限制：C / C++语言 65536KB；其他语言 589824KB
//题目描述：
//拉齐有一个01序列，他可以对这个序列进行任意多次变换，每次变换都是把序列的最后若干个元素放到最前面，例如：010011，将最后3个元素011放到最前面，序列变为011010。所有变换结束后，拉齐需要挑出一个全为1的连续区间，要求最大化区间长度。
//输入
//共一行，一个01串，仅包含0或1。序列长度不超过50000。
//输出
//一个整数，表示最长区间的长度。
//样例输入
//11011
//样例输出
//4
//提示
//首先做一次变换，将末尾两个1提到开头变成11110，显然最长区间是1111，长度为4。
//规则
//请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果
//点击“调试”亦可保存代码
//编程题可以使用本地编译器，此页面不记录跳出次数

//拉齐有一个01序列，他可以对这个序列进行任意多次变换，每次变换都是把序列的最后若干个元素放到最前面，例如：010011，将最后3个元素011放到最前面，序列变为011010。所有变换结束后，拉齐需要挑出一个全为1的连续区间，要求最大化区间长度。
//输入
//共一行，一个01串，仅包含0或1。序列长度不超过50000。
//输出
//一个整数，表示最长区间的长度。
//样例输入
//11011
//样例输出
//4
//*******小星星的代码，过了百分之九十几************************************************
#include <string>
#include <iostream>
using namespace std;

int Calucate(string str)
{
	int max = 0;
	int cur = 0;
	for (int i = 0; i < str.size(); i++)
	{
		if (str[i] == '1')
			cur++;
		else
			cur = 0;
		if (cur >max)
			max = cur;
	}
	cur = 0;
	for (int i = 0; i < str.size(); i++)
	{
		if (str[i] == '1')
			cur++;
		else
			break;
	}
	for (int i = str.size() - 1; i >= 0; i--)
	{
		if (str[i] == '1')
			cur++;
		else
			break;
	}
	if (cur > max)
		max = cur;
	return max;
}

int main()
{
	string str;
	cin >> str;
	int ret = Calucate(str);
	cout << str << endl;
	return 0;
}